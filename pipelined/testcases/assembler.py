### GENERATED BY CLAUDE ###

import os
import sys
import re

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 assembler.py <filename.s>")
        sys.exit(1)

    filename = sys.argv[1]

    try:
        with open(os.path.join("testcases", filename), 'r') as file:
            content = file.read()

        # First pass: collect all labels and their addresses
        labels = {}
        current_address = 0
        
        lines = content.splitlines()
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line or stripped_line.startswith('#'):
                continue
                
            # Extract label if present
            if ':' in stripped_line:
                label = stripped_line.split(':')[0].strip()
                labels[label] = current_address
                # If line only contains a label, continue to next line
                if stripped_line.endswith(':'):
                    continue
                # Otherwise, process the instruction after the label
                stripped_line = stripped_line.split(':', 1)[1].strip()
                
            # Count this as an instruction (4 bytes)
            current_address += 4

        # Second pass: generate machine code
        current_address = 0
        instruction_index = 0
        instructions = []
        
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line or stripped_line.startswith('#'):
                continue
                
            # Skip label-only lines or extract instruction after label
            if ':' in stripped_line:
                if stripped_line.endswith(':'):
                    continue
                stripped_line = stripped_line.split(':', 1)[1].strip()
            
            # Remove comments if any
            if '#' in stripped_line:
                stripped_line = stripped_line.split('#')[0].strip()
                
            # Remove commas and parse tokens
            stripped_line = stripped_line.replace(',', ' ')
            tokens = stripped_line.split()
            
            if not tokens:
                continue
                
            # Handle NOP instruction
            if tokens[0] == "nop":
                # NOP is encoded as all zeros
                binary_instruction = "00000000000000000000000000000000"
                instructions.append(f"        cpu.imem.memory[{instruction_index}] = 32'b{binary_instruction};")
                current_address += 4
                instruction_index += 1
                continue
                
            # Initialize fields
            opcode = "0000000"
            funct3 = "000"
            funct7 = "0000000"
            rd = "00000"
            rs1 = "00000"
            rs2 = "00000"
            imm = None
            
            instruction_type = get_instruction_type(tokens[0])
            
            # Process based on instruction type
            if instruction_type == 'R':
                # R-type: add, sub, or, and
                opcode = "0110011"
                rd = format_register(tokens[1])
                rs1 = format_register(tokens[2])
                rs2 = format_register(tokens[3])
                
                match tokens[0]:
                    case "add":
                        funct3 = "000"
                        funct7 = "0000000"
                    case "sub":
                        funct3 = "000"
                        funct7 = "0100000"
                    case "or":
                        funct3 = "110"
                        funct7 = "0000000"
                    case "and":
                        funct3 = "111"
                        funct7 = "0000000"
                
                binary_instruction = funct7 + rs2 + rs1 + funct3 + rd + opcode
                
            elif instruction_type == 'I':
                # I-type: addi, ld
                if tokens[0] == "addi":
                    opcode = "0010011"
                    funct3 = "000"
                    rd = format_register(tokens[1])
                    rs1 = format_register(tokens[2])
                    imm = format_immediate(tokens[3], 12)
                    
                    binary_instruction = imm + rs1 + funct3 + rd + opcode
                    
                elif tokens[0] == "ld":
                    opcode = "0000011"
                    funct3 = "010"
                    rd = format_register(tokens[1])
                    
                    # Parse memory operand: offset(base)
                    memory_op = tokens[2]
                    offset_match = re.match(r'(-?\d+)\(([xX]\d+)\)', memory_op)
                    if offset_match:
                        offset = offset_match.group(1)
                        base_reg = offset_match.group(2)
                        imm = format_immediate(offset, 12)
                        rs1 = format_register(base_reg)
                    else:
                        print(f"Error: Invalid memory operand format: {memory_op}")
                        sys.exit(1)
                    
                    binary_instruction = imm + rs1 + funct3 + rd + opcode
            
            elif instruction_type == 'S':
                # S-type: sd
                opcode = "0100011"
                funct3 = "010"
                rs2 = format_register(tokens[1])  # Source register
                
                # Parse memory operand: offset(base)
                memory_op = tokens[2]
                offset_match = re.match(r'(-?\d+)\(([xX]\d+)\)', memory_op)
                if offset_match:
                    offset = offset_match.group(1)
                    base_reg = offset_match.group(2)
                    imm = format_immediate(offset, 12)
                    rs1 = format_register(base_reg)
                else:
                    print(f"Error: Invalid memory operand format: {memory_op}")
                    sys.exit(1)
                
                # S-type immediate is split into imm[11:5] and imm[4:0]
                imm_11_5 = imm[0:7]  # First 7 bits
                imm_4_0 = imm[7:12]  # Last 5 bits
                
                binary_instruction = imm_11_5 + rs2 + rs1 + funct3 + imm_4_0 + opcode
            
            elif instruction_type == 'B':
                # B-type: beq
                opcode = "1100011"
                funct3 = "000"
                rs1 = format_register(tokens[1])
                rs2 = format_register(tokens[2])
                
                # Calculate branch target
                target = tokens[3]
                if target in labels:
                    offset = labels[target] - current_address
                else:
                    try:
                        offset = int(target)
                    except ValueError:
                        print(f"Error: Unknown label or invalid offset: {target}")
                        sys.exit(1)
                
                # B-type immediate encoding is complicated
                imm = format_immediate(offset, 13)  # 13 bits, but bit[0] is always 0
                
                # B-type immediates are rearranged: imm[12|10:5|4:1|11]
                imm_12 = imm[0:1]    # imm[12]
                imm_11 = imm[1:2]    # imm[11]
                imm_10_5 = imm[2:8]  # imm[10:5]
                imm_4_1 = imm[8:12]  # imm[4:1]
                
                binary_instruction = imm_12 + imm_10_5 + rs2 + rs1 + funct3 + imm_4_1 + imm_11 + opcode
            
            else:
                print(f"Error: Unknown instruction: {tokens[0]}")
                sys.exit(1)
            
            instructions.append(f"        cpu.imem.memory[{instruction_index}] = 32'b{binary_instruction};")
            current_address += 4
            instruction_index += 1

        # Generate the full testbench file
        generate_testbench(instructions)

    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        sys.exit(1)

def generate_testbench(instructions):
    testbench = '''`timescale 1ns/1ps

module testbench_pipelined();
    reg clk;
    reg reset;
    wire end_program;

    integer cycle_count = 0;
    real execution_time;
    real execution_time_ms;
    real execution_time_us;
    integer execution_time_p;
        
    initial begin
        clk = 0;
        reset = 1;
        
        // Initialize instruction memory first
{instructions}
        
        // promper initialization
        #10 reset = 0;
        
        forever #5 clk = ~clk; 
    end
    
    cpu_pipelined cpu(
        .clk(clk),
        .reset(reset),
        .end_program(end_program)
    );
        
    integer i;
    initial begin
        $dumpfile("test_results/cpu_pipelined_test.vcd");
        $dumpvars(0, testbench_pipelined);
        
        @(negedge reset);

        // Run simulation until end_program is high
        while (!end_program) begin
            @(posedge clk);
        end
        
        // Allow pipeline to flush completely
        repeat (5) @(posedge clk);

        // Print register contents
        $display("Register file contents:");
        for (i = 0; i < 32; i = i + 1) begin
            $display("x%0d = %0d [0x%h]", i, cpu.reg_file.registers[i], cpu.reg_file.registers[i]);
        end

        // Memory contents
        $display("\\nMemory contents:");
        for (i = 0; i < 32; i = i + 1) begin
            $display("mem[%0d] = %0d [0x%h]", i, cpu.dmem.memory[i], cpu.dmem.memory[i]);
        end

        $writememh("modules/data_memory.hex", cpu.dmem.memory);
        $display("\\nData memory contents written to 'modules/data_memory.hex'");

        execution_time = cycle_count * 10e-9; // Convert cycles to seconds
        execution_time_ms = cycle_count * 10e-6; // Convert cycles to milliseconds
        execution_time_us = cycle_count * 10e-3; // Convert cycles to microseconds
        execution_time_p = cycle_count * 10000; // Convert cycles to picoseconds

        $display("\\nTotal Execution Time:");
        $display("Seconds: %0.9f s", execution_time);
        $display("Milliseconds: %0.6f ms", execution_time_ms);
        $display("Microseconds: %0.3f µs", execution_time_us);
        $display("Picoseconds: %0d ps", execution_time_p);

        $finish;
    end
    
    always @(posedge clk) begin
        if (!reset) begin
            cycle_count = cycle_count + 1;
            $display("--------------------------------");
            $display("Time=%0t, Cycle=%0d", $time, cycle_count);
            
            $display("PIPELINE STATE:");
            $display("IF Stage: PC=%h, Instruction=%h", cpu.pc_current, cpu.instruction);
            
            // Decode current instruction in IF stage
            if (cpu.instruction != 0) begin
                case(cpu.instruction[6:0])
                    7'b0110011: begin // R-type 
                        case(cpu.instruction[14:12])
                            3'b000: begin
                                if (cpu.instruction[31:25] == 7'b0000000)
                                    $display("IF: add x%0d, x%0d, x%0d", 
                                        cpu.instruction[11:7], cpu.instruction[19:15], cpu.instruction[24:20]);
                                else
                                    $display("IF: sub x%0d, x%0d, x%0d", 
                                        cpu.instruction[11:7], cpu.instruction[19:15], cpu.instruction[24:20]);
                            end
                            3'b111: $display("IF: and x%0d, x%0d, x%0d", 
                                cpu.instruction[11:7], cpu.instruction[19:15], cpu.instruction[24:20]);
                            3'b110: $display("IF: or x%0d, x%0d, x%0d", 
                                cpu.instruction[11:7], cpu.instruction[19:15], cpu.instruction[24:20]);
                        endcase
                    end
                    7'b0000011: $display("IF: ld x%0d, %0d(x%0d)", 
                        cpu.instruction[11:7], $signed({{52{cpu.instruction[31]}}, cpu.instruction[31:20]}), cpu.instruction[19:15]);
                    7'b0100011: $display("IF: sd x%0d, %0d(x%0d)", 
                        cpu.instruction[24:20], $signed({{52{cpu.instruction[31]}}, cpu.instruction[31:25], cpu.instruction[11:7]}), cpu.instruction[19:15]);
                    7'b1100011: $display("IF: beq x%0d, x%0d, %0d", 
                        cpu.instruction[19:15], cpu.instruction[24:20], 
                        $signed({{51{cpu.instruction[31]}}, cpu.instruction[7], cpu.instruction[30:25], cpu.instruction[11:8], 1'b0}));
                    7'b0010011: $display("IF: addi x%0d, x%0d, %0d",
                        cpu.instruction[11:7], cpu.instruction[19:15], 
                        $signed({{52{cpu.instruction[31]}}, cpu.instruction[31:20]}));
                endcase
            end

            // Show ID stage activity
            $display("ID Stage: rs1=x%0d (%0d), rs2=x%0d (%0d), rd=x%0d", 
                cpu.rs1, cpu.reg_read_data1, cpu.rs2, cpu.reg_read_data2, cpu.reg_rd);
            
            // Show EX stage activity
            $display("EX Stage: ALU Result=%0h", cpu.alu_result);
            
            // Show MEM stage activity
            if (cpu.mem_write)
                $display("MEM Stage: Writing %0d to address %0d", 
                    cpu.reg_read_data2, cpu.alu_result);
            if (cpu.mem_read)
                $display("MEM Stage: Reading from address %0d, value=%0d", 
                    cpu.alu_result, cpu.mem_read_data);
                
            // Show WB stage activity
            if (cpu.reg_write && cpu.reg_rd != 0)
                $display("WB Stage: Writing %0d to register x%0d", 
                    cpu.reg_write_data, cpu.reg_rd);
            
            // Control signals
            $display("Control signals: branch=%b, mem_read=%b, mem_to_reg=%b, mem_write=%b, alu_src=%b, reg_write=%b", 
                cpu.branch, cpu.mem_read, cpu.mem_to_reg, cpu.mem_write, cpu.alu_src, cpu.reg_write);
            
            // Add pipeline register contents - MORE DETAILED INFO
            $display("Pipeline Registers:");
            $display("IF/ID: PC=%h, Instruction=%h", cpu.if_id_pc, cpu.if_id_instruction);
            $display("ID/EX: PC=%h, Instruction=%h, rs1=x%0d, rs2=x%0d, rd=x%0d, RegWrite=%b, MemWrite=%b", 
                     cpu.id_ex_pc, cpu.id_ex_instruction, cpu.id_ex_rs1, cpu.id_ex_rs2, 
                     cpu.id_ex_rd, cpu.id_ex_reg_write, cpu.id_ex_mem_write);
            $display("EX/MEM: Instruction=%h, rd=x%0d, RegWrite=%b, MemWrite=%b, ALUResult=%h", 
                     cpu.ex_mem_instruction, cpu.ex_mem_rd, cpu.ex_mem_reg_write, 
                     cpu.ex_mem_mem_write, cpu.ex_mem_alu_result);
            $display("MEM/WB: Instruction=%h, rd=x%0d, RegWrite=%b, MemToReg=%b", 
                     cpu.mem_wb_instruction, cpu.mem_wb_rd, cpu.mem_wb_reg_write, 
                     cpu.mem_wb_mem_to_reg);
            $display("Register Values:");
            for (i = 0; i < 32; i = i + 1) begin
                $display("reg[%0d]=%0d", i, cpu.reg_file.registers[i]);
            end
                        
                // Hazard detection information
                if (cpu.stall) begin  // Use cpu.stall directly instead of cpu.hazard_detection_unit.stall_pipeline
                    $display("HAZARD DETECTED: Stalling pipeline");
                    $display("Load-use hazard between instructions at PC=%h and PC=%h", 
                            cpu.if_id_pc - 4, cpu.if_id_pc);
                end

                // Forwarding information
                if (cpu.forwardA != 0 || cpu.forwardB != 0) begin  // Use cpu.forwardA/B directly
                    $display("Forwarding active:");
                    if (cpu.forwardA == 2'b10)
                        $display("EX → EX Forwarding to rs1 (x%0d)", cpu.id_ex_rs1);
                    if (cpu.forwardA == 2'b01)
                        $display("MEM → EX Forwarding to rs1 (x%0d)", cpu.id_ex_rs1);
                    if (cpu.forwardB == 2'b10)
                        $display("EX → EX Forwarding to rs2 (x%0d)", cpu.id_ex_rs2);
                    if (cpu.forwardB == 2'b01)
                        $display("MEM → EX Forwarding to rs2 (x%0d)", cpu.id_ex_rs2);
                end

                // Branch information
                if (cpu.branch && cpu.zero) begin  // Use cpu.zero instead of cpu.alu_zero
                    $display("Branch at PC=%h: Taking branch", cpu.pc_current);
                    if (cpu.branch_mispredicted)  // Use cpu.branch_mispredicted directly
                        $display("Branch mispredicted: Pipeline flush required");
                end

                // Pipeline stall/flush status
                if (cpu.flush)  // Use cpu.flush instead of cpu.if_id_flush
                    $display("Pipeline flushed");
        end
    end
    
endmodule'''

    # Insert the instructions into the template
    instructions_str = '\n'.join(instructions)
    testbench = testbench.replace('{instructions}', instructions_str)
    
    # Write the testbench to a file
    output_file = "verilog/testbench_pipelined.v"
    with open(output_file, 'w') as f:
        f.write(testbench)
    
    print(f"Generated testbench file: {output_file}")


def get_instruction_type(instruction):
    if instruction in ["add", "sub", "or", "and"]:
        return 'R'
    elif instruction in ["addi", "ld"]:
        return 'I'
    elif instruction in ["sd"]:
        return 'S'
    elif instruction in ["beq"]:
        return 'B'
    elif instruction in ["nop"]:
        return 'NOP'  # Special type for NOP
    else:
        return None

def format_register(reg):
    # Extract register number and format to 5-bit binary
    if reg.lower().startswith('x'):
        reg_num = int(reg[1:])
        return format(reg_num, "05b")
    else:
        print(f"Error: Invalid register format: {reg}")
        sys.exit(1)

def format_immediate(imm_str, width):
    # Convert immediate value to binary with sign extension
    try:
        imm = int(imm_str)
        if imm < 0:
            # For negative numbers, use two's complement representation
            imm = (1 << width) + imm
        # Format to specified width binary
        return format(imm & ((1 << width) - 1), f"0{width}b")
    except ValueError:
        print(f"Error: Invalid immediate value: {imm_str}")
        sys.exit(1)

if __name__ == "__main__":
    main()
