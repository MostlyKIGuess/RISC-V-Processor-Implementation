### GENERATED BY CLAUDE ###

import os
import sys
import re

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 assembler.py <filename.s>")
        sys.exit(1)

    filename = sys.argv[1]

    try:
        with open(os.path.join("testcases", filename), 'r') as file:
            content = file.read()

        # First pass: collect all labels and their addresses
        labels = {}
        current_address = 0
        
        lines = content.splitlines()
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line or stripped_line.startswith('#'):
                continue
                
            # Extract label if present
            if ':' in stripped_line:
                label = stripped_line.split(':')[0].strip()
                labels[label] = current_address
                # If line only contains a label, continue to next line
                if stripped_line.endswith(':'):
                    continue
                # Otherwise, process the instruction after the label
                stripped_line = stripped_line.split(':', 1)[1].strip()
                
            # Count this as an instruction (4 bytes)
            current_address += 4

        # Second pass: generate machine code
        current_address = 0
        instruction_index = 1
        instructions = []
        
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line or stripped_line.startswith('#'):
                continue
                
            # Skip label-only lines or extract instruction after label
            if ':' in stripped_line:
                if stripped_line.endswith(':'):
                    continue
                stripped_line = stripped_line.split(':', 1)[1].strip()
            
            # Remove comments if any
            if '#' in stripped_line:
                stripped_line = stripped_line.split('#')[0].strip()
                
            # Remove commas and parse tokens
            stripped_line = stripped_line.replace(',', ' ')
            tokens = stripped_line.split()
            
            if not tokens:
                continue
                
            # Handle NOP instruction
            if tokens[0] == "nop":
                # NOP is encoded as all zeros
                binary_instruction = "00000000000000000000000000000000"
                instructions.append(f"        cpu.imem.memory[{instruction_index}] = 32'b{binary_instruction};")
                current_address += 4
                instruction_index += 1
                continue
                
            # Initialize fields
            opcode = "0000000"
            funct3 = "000"
            funct7 = "0000000"
            rd = "00000"
            rs1 = "00000"
            rs2 = "00000"
            imm = None
            
            instruction_type = get_instruction_type(tokens[0])
            
            # Process based on instruction type
            if instruction_type == 'R':
                # R-type: add, sub, or, and
                opcode = "0110011"
                rd = format_register(tokens[1])
                rs1 = format_register(tokens[2])
                rs2 = format_register(tokens[3])
                
                match tokens[0]:
                    case "add":
                        funct3 = "000"
                        funct7 = "0000000"
                    case "sub":
                        funct3 = "000"
                        funct7 = "0100000"
                    case "or":
                        funct3 = "110"
                        funct7 = "0000000"
                    case "and":
                        funct3 = "111"
                        funct7 = "0000000"
                
                binary_instruction = funct7 + rs2 + rs1 + funct3 + rd + opcode
                
            elif instruction_type == 'I':
                # I-type: addi, ld
                if tokens[0] == "addi":
                    opcode = "0010011"
                    funct3 = "000"
                    rd = format_register(tokens[1])
                    rs1 = format_register(tokens[2])
                    imm = format_immediate(tokens[3], 12)
                    
                    binary_instruction = imm + rs1 + funct3 + rd + opcode
                    
                elif tokens[0] == "ld":
                    opcode = "0000011"
                    funct3 = "010"
                    rd = format_register(tokens[1])
                    
                    # Parse memory operand: offset(base)
                    memory_op = tokens[2]
                    offset_match = re.match(r'(-?\d+)\(([xX]\d+)\)', memory_op)
                    if offset_match:
                        offset = offset_match.group(1)
                        base_reg = offset_match.group(2)
                        imm = format_immediate(offset, 12)
                        rs1 = format_register(base_reg)
                    else:
                        print(f"Error: Invalid memory operand format: {memory_op}")
                        sys.exit(1)
                    
                    binary_instruction = imm + rs1 + funct3 + rd + opcode
            
            elif instruction_type == 'S':
                # S-type: sd
                opcode = "0100011"
                funct3 = "010"
                rs2 = format_register(tokens[1])  # Source register
                
                # Parse memory operand: offset(base)
                memory_op = tokens[2]
                offset_match = re.match(r'(-?\d+)\(([xX]\d+)\)', memory_op)
                if offset_match:
                    offset = offset_match.group(1)
                    base_reg = offset_match.group(2)
                    imm = format_immediate(offset, 12)
                    rs1 = format_register(base_reg)
                else:
                    print(f"Error: Invalid memory operand format: {memory_op}")
                    sys.exit(1)
                
                # S-type immediate is split into imm[11:5] and imm[4:0]
                imm_11_5 = imm[0:7]  # First 7 bits
                imm_4_0 = imm[7:12]  # Last 5 bits
                
                binary_instruction = imm_11_5 + rs2 + rs1 + funct3 + imm_4_0 + opcode
            
            elif instruction_type == 'B':
                # B-type: beq
                opcode = "1100011"
                funct3 = "000"
                rs1 = format_register(tokens[1])
                rs2 = format_register(tokens[2])
                
                # Calculate branch target
                target = tokens[3]
                if target in labels:
                    offset = labels[target] - current_address
                else:
                    try:
                        offset = int(target)
                    except ValueError:
                        print(f"Error: Unknown label or invalid offset: {target}")
                        sys.exit(1)
                
                # B-type immediate encoding is complicated
                imm = format_immediate(offset, 13)  # 13 bits, but bit[0] is always 0
                
                # B-type immediates are rearranged: imm[12|10:5|4:1|11]
                imm_12 = imm[0:1]    # imm[12]
                imm_11 = imm[1:2]    # imm[11]
                imm_10_5 = imm[2:8]  # imm[10:5]
                imm_4_1 = imm[8:12]  # imm[4:1]
                
                binary_instruction = imm_12 + imm_10_5 + rs2 + rs1 + funct3 + imm_4_1 + imm_11 + opcode
            
            else:
                print(f"Error: Unknown instruction: {tokens[0]}")
                sys.exit(1)
            
            instructions.append(f"        cpu.imem.memory[{instruction_index}] = 32'b{binary_instruction};")
            current_address += 4
            instruction_index += 1

        # Generate the full testbench file
        generate_testbench(instructions)

    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        sys.exit(1)

def generate_testbench(instructions):
    testbench = '''`timescale 1ns/1ps

module testbench_pipelined();
    reg clk;
    reg reset;
    wire end_program;


    integer cycle_count = 0;
    real execution_time;
    real execution_time_ms;
    real execution_time_us;
    integer execution_time_p;
        
    initial begin
        clk = 0;
        reset = 1;
        #6 reset = 0;
        
        cpu.imem.memory[0] = 32'b00000000000000000000000000010011;
{instructions}
    
        forever #5 clk = ~clk; 
    end
    
    cpu_pipelined cpu(
        .clk(clk),
        .reset(reset),
        .end_program(end_program)
    );
        
    integer i;
    initial begin
        $dumpfile("test_results/cpu_pipelined_test.vcd");
        $dumpvars(0, testbench_pipelined);
        
        @(negedge reset);

        // Run simulation until end_program is high
        while (!end_program) begin
            @(posedge clk);
        end

        // Print register contents
        $display("Register file contents:");
        for (i = 0; i < 32; i = i + 1) begin
            $display("x%0d = %0d [0x%h]", i, cpu.reg_file.registers[i], cpu.reg_file.registers[i]);
        end

        // Memory contents
        $display("\\nMemory contents:");
        for (i = 0; i < 32; i = i + 1) begin
            $display("mem[%0d] = %0d [0x%h]", i, cpu.dmem.memory[i], cpu.dmem.memory[i]);
        end

        $writememh("modules/data_memory.hex", cpu.dmem.memory);
        $display("\\nData memory contents written to 'modules/data_memory.hex'");

        execution_time = cycle_count * 10e-9; // Convert cycles to seconds
        execution_time_ms = cycle_count * 10e-6; // Convert cycles to milliseconds
        execution_time_us = cycle_count * 10e-3; // Convert cycles to microseconds
        execution_time_p = cycle_count * 10000; // Convert cycles to picoseconds

        $display("\\nTotal Execution Time:");
        $display("Seconds: %0.9f s", execution_time);
        $display("Milliseconds: %0.6f ms", execution_time_ms);
        $display("Microseconds: %0.3f µs", execution_time_us);
        $display("Picoseconds: %0d ps", execution_time_p);

        $finish;
    end
    
endmodule'''

    # Insert the instructions into the template
    instructions_str = '\n'.join(instructions)
    testbench = testbench.replace('{instructions}', instructions_str)
    
    # Write the testbench to a file
    output_file = "verilog/testbench_pipelined.v"
    with open(output_file, 'w') as f:
        f.write(testbench)
    
    print(f"Generated testbench file: {output_file}")

def get_instruction_type(instruction):
    if instruction in ["add", "sub", "or", "and"]:
        return 'R'
    elif instruction in ["addi", "ld"]:
        return 'I'
    elif instruction in ["sd"]:
        return 'S'
    elif instruction in ["beq"]:
        return 'B'
    elif instruction in ["nop"]:
        return 'NOP'  # Special type for NOP
    else:
        return None

def format_register(reg):
    # Extract register number and format to 5-bit binary
    if reg.lower().startswith('x'):
        reg_num = int(reg[1:])
        return format(reg_num, "05b")
    else:
        print(f"Error: Invalid register format: {reg}")
        sys.exit(1)

def format_immediate(imm_str, width):
    # Convert immediate value to binary with sign extension
    try:
        imm = int(imm_str)
        if imm < 0:
            # For negative numbers, use two's complement representation
            imm = (1 << width) + imm
        # Format to specified width binary
        return format(imm & ((1 << width) - 1), f"0{width}b")
    except ValueError:
        print(f"Error: Invalid immediate value: {imm_str}")
        sys.exit(1)

if __name__ == "__main__":
    main()
